<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Boggle Machine</title>

  <!-- CSS styles go in the head -->
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0f1115; /* dark backdrop */
    }
    #app {
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      display: block; /* avoids extra gaps */
    }
  </style>
</head>

<body>
  <!-- PIXI canvas mounts here -->
  <div id="app"></div>

  <!-- Load PIXI -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>

  <!-- Your game code -->
  <script>
    // ... JS code including the layout() logic I sent you earlier ...
  </script>
</body>
</html>

<body>
<div id="app"></div>

<script src="https://unpkg.com/pixi.js@7/dist/pixi.min.js"></script>
<script>
(async function () {
  // ---------- CONFIG ----------
  const BASE = { w: 320, h: 480 };
 const COORDS_URL = "ui_coords_full_with_timer_counter.json";

  // 5Ã—5 grid; top-left tile CENTER you gave earlier
  const GRID = {
    rows: 5, cols: 5,
    size: 38, gutter: 5,
    topLeftCenter: { x: 72.366, y: 254.000 }
  };

  // sizes (base pixels)
  const TIMER_R   = 26;
  const COUNTER_R = 18;
  const BTN_SIZE  = { w: 60, h: 24 };

  // ---------- PIXI ----------
  const app = new PIXI.Application({ backgroundAlpha: 0, resizeTo: window });
  document.getElementById("app").appendChild(app.view);
  const root = new PIXI.Container(); app.stage.addChild(root);

  function layout(){
    const sw=app.renderer.width, sh=app.renderer.height;
    const s=Math.min(sw/BASE.w, sh/BASE.h);
    root.scale.set(s);
    root.position.set((sw-BASE.w*s)/2,(sh-BASE.h*s)/2);
  }
  window.addEventListener("resize", layout);

  const frameLayer=new PIXI.Container(), gridLayer=new PIXI.Container(),
        uiLayer=new PIXI.Container(),    fxLayer=new PIXI.Container();
  root.addChild(frameLayer, gridLayer, uiLayer, fxLayer);

  // helpers
  const DPR = window.devicePixelRatio || 1;
  const suf = () => DPR>=2.5 ? "@3x" : DPR>=1.5 ? "@2x" : "@1x";
  async function tryLoad(u){ try{ return await PIXI.Assets.load(u);}catch{ return null; } }
  async function firstTexture(paths){ for(const p of paths){ const t=await tryLoad(p); if(t) return t; } return null; }

  // load coords
  const coords = await (await fetch(COORDS_URL,{cache:"no-store"})).json();

  // frame (auto @1x/2x/3x)
  const frameTex = await firstTexture([`assets/frame/frame${suf()}.png`,`assets/frame/frame@1x.png`]);
  if (frameTex){ const s=new PIXI.Sprite(frameTex); s.width=BASE.w; s.height=BASE.h; frameLayer.addChild(s); }
  else { frameLayer.addChild(new PIXI.Graphics().roundRect(0,0,BASE.w,BASE.h,12).fill(0x1a2029)); }

  // ---------- TILES: coded base + overlay PNG ----------
  const overlayTex = await firstTexture([`assets/tiles/tile_base${suf()}.png`,`assets/tiles/tile_base@1x.png`]);
  function makeTile(x,y,size){
    const cont = new PIXI.Container(); cont.position.set(x,y); cont.eventMode="static";

    // 1) coded base (white rounded square with subtle stroke)
    const baseG = new PIXI.Graphics()
      .roundRect(-size/2,-size/2,size,size,5).fill(0xf8fbff)
      .rect(-size/2,-size/2,size,size).stroke({width:1,color:0xcad3df,alpha:0.9});
    cont.addChild(baseG);

    // 2) letter
    const letter = new PIXI.Text("", new PIXI.TextStyle({
      fontFamily:"system-ui, -apple-system, Segoe UI, Roboto",
      fontWeight:"800",
      fontSize: Math.round(size*0.72),
      fill: 0x23303a,
      stroke: 0xffffff,
      strokeThickness: 2
    }));
    letter.anchor.set(0.5);
    cont.addChild(letter);

    // 3) overlay (filigree corners)
    let overlay=null;
    if (overlayTex){ overlay = new PIXI.Sprite(overlayTex); overlay.anchor.set(0.5); overlay.width=overlay.height=size; cont.addChild(overlay); }

    return { cont, letter, overlay };
  }

  const tiles=[], letters=[];
  for (let r=0;r<GRID.rows;r++){
    for (let c=0;c<GRID.cols;c++){
      const cx = GRID.topLeftCenter.x + c*(GRID.size+GRID.gutter);
      const cy = GRID.topLeftCenter.y + r*(GRID.size+GRID.gutter);
      const { cont, letter, overlay } = makeTile(cx,cy,GRID.size);
      gridLayer.addChild(cont); tiles.push({cont,overlay}); letters.push(letter);
    }
  }

  // letters (placeholder distribution)
  const ALPH="EEEEEEEEEEEEAAAAAAAIIIIIIIONNNNRRRRTTTTTLLLLSSSSUUUUDDGGBBCCMMPPFFHHVVWWYYKJXQZ";
  function rollLetters(){ for(let i=0;i<letters.length;i++){ letters[i].text=ALPH[Math.floor(Math.random()*ALPH.length)]; letters[i].alpha=1; tiles[i].cont.alpha=1; if(tiles[i].overlay) tiles[i].overlay.tint=0xFFFFFF; } }
  rollLetters();

  // selection MVP (tap to toggle; real adjacency comes next)
  const selected=[];
  tiles.forEach((t,i)=>{
    t.cont.on("pointerdown",()=>{
      const k=selected.indexOf(i);
      if(k>=0){ selected.splice(k,1); t.cont.alpha=1; if(t.overlay) t.overlay.tint=0xFFFFFF; }
      else    { selected.push(i);     t.cont.alpha=0.95; if(t.overlay) t.overlay.tint=0xE9FFD6; }
    });
  });
  function clearSelection(){ selected.splice(0); tiles.forEach(t=>{ t.cont.alpha=1; if(t.overlay) t.overlay.tint=0xFFFFFF; }); }

  // counter (coords.counter is TOP-LEFT)
  const counterPos = coords.counter ? { x: coords.counter.x + COUNTER_R, y: coords.counter.y + COUNTER_R } : { x:160, y:40 };
  const counterBg = new PIXI.Graphics().circle(0,0,COUNTER_R).fill(0x24303a);
  counterBg.position.set(counterPos.x, counterPos.y); uiLayer.addChild(counterBg);
  const counterText = new PIXI.Text("0", new PIXI.TextStyle({fontFamily:"system-ui, -apple-system, Segoe UI, Roboto", fontWeight:"800", fontSize:16, fill:0xffffff}));
  counterText.anchor.set(0.5); counterText.position.copyFrom(counterBg.position); uiLayer.addChild(counterText);
  let wordsCount=0; function setWordCount(n){ counterText.text=String(n); }
  function submitWord(){ if(!selected.length) return; wordsCount++; setWordCount(wordsCount); clearSelection(); }

  // buttons (PNG + pressed)
  function btnPaths(base){ const s=suf(); return {up:`assets/buttons/${base}${s}.png`, down:`assets/buttons/${base}Press${s}.png`}; }
  function findBtn(which){ const b=(coords.buttons||[]).find(b=>which==="green"?b.id==="btn_green":b.id==="btn_red"); return b?{x:b.x,y:b.y}:null; }
  async function makeButton(which, baseName, onClick){
    const center=findBtn(which); if(!center) return;
    const p=btnPaths(baseName); const [texUp,texDown]=await Promise.all([tryLoad(p.up),tryLoad(p.down)]);
    const s=new PIXI.Sprite(texUp||texDown); s.anchor.set(0.5); s.position.set(center.x,center.y);
    if(s.width&&s.height){ const sx=BTN_SIZE.w/s.width, sy=BTN_SIZE.h/s.height; s.scale.set(sx,sy); }
    s.eventMode="static"; s.cursor="pointer";
    s.hitArea=new PIXI.Rectangle(-BTN_SIZE.w/2,-BTN_SIZE.h/2,BTN_SIZE.w,BTN_SIZE.h);
    s.on("pointerdown",()=>{ if(texDown) s.texture=texDown; });
    s.on("pointerup",()=>{ if(texUp) s.texture=texUp; onClick&&onClick(); });
    s.on("pointerupoutside",()=>{ if(texUp) s.texture=texUp; });
    s.on("pointercancel",()=>{ if(texUp) s.texture=texUp; });
    uiLayer.addChild(s);
  }
  await makeButton("green","leftButton", submitWord);
  await makeButton("red","rightButton",  clearSelection);

  // timer (coords.timer.face is TOP-LEFT; rotate)
  const faceTL = coords.timer && coords.timer.face ? {x:coords.timer.face.x, y:coords.timer.face.y} : {x:140,y:392};
  const faceContainer=new PIXI.Container(); faceContainer.position.set(faceTL.x+TIMER_R, faceTL.y+TIMER_R); uiLayer.addChild(faceContainer);
  const faceTex=await firstTexture([`assets/timer/face${suf()}.png`,`assets/timer/face@1x.png`]);
  if(faceTex){ const s=new PIXI.Sprite(faceTex); s.anchor.set(0.5); s.width=s.height=TIMER_R*2; faceContainer.addChild(s); }
  else { faceContainer.addChild(new PIXI.Graphics().circle(0,0,TIMER_R).fill(0x2b2f35).stroke({width:2,color:0x000,alpha:.5})); }

  // lights (coded dots from JSON)
  const bulbs=[];
  (coords.lights||[]).forEach(L=>{
    const dot=new PIXI.Graphics().circle(0,0,3.6).fill(0xfff080);
    const spr=new PIXI.Sprite(app.renderer.generateTexture(dot)); spr.anchor.set(0.5);
    spr.position.set(L.x,L.y); spr.alpha=0.7; const blur=new PIXI.filters.BlurFilter(); blur.blur=1.4; spr.filters=[blur];
    fxLayer.addChild(spr); bulbs.push(spr);
  });

  // round timer loop
  const ROUND_S=180, WARN_S=10; let elapsed=0, running=true, warned=false;
  app.ticker.add((delta)=>{
    layout();
    if(!running) return;
    const dt=delta/60; elapsed+=dt;
    faceContainer.rotation=(elapsed*(Math.PI*2/ROUND_S))%(Math.PI*2);
    const rem=ROUND_S-elapsed;
    if(!warned && rem<=WARN_S && rem>0){ warned=true; bulbs.forEach(b=>b.alpha=1.0); }
    if(elapsed>=ROUND_S){
      running=false; faceContainer.rotation=0;
      let n=0; const iv=setInterval(()=>{ bulbs.forEach(b=>b.tint=(n%2?0xfff080:0xd92626)); if(++n>=4) clearInterval(iv); },160);
      // TODO: results/splash
    }
  });

  // keys
  window.addEventListener("keydown", e=>{
    if(e.key==="Enter") submitWord();
    if(e.key==="Escape"||e.key==="Backspace") clearSelection();
    if(e.key===" "){ e.preventDefault(); running=!running; }
  });
})();
</script>
</body>
</html>


